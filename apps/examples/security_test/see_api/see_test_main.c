/* ****************************************************************
*
* Copyright 2019 Samsung Electronics All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
******************************************************************/

/****************************************************************************
 * Included Files
 ****************************************************************************/

#include "mbedtls/base64.h"
#include "mbedtls/x509.h"
#include "mbedtls/x509_crt.h"
#include "mbedtls/timing.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mbedtls/see_api.h"
#include "mbedtls/see_misc.h"

/*
 * Definition for handling pthread
 */
#define SEE_TEST_PRIORITY     100
#define SEE_TEST_STACK_SIZE   51200
#define SEE_TEST_SCHED_POLICY SCHED_RR

struct pthread_arg {
	int argc;
	char **argv;
};

#define see_selfprintf printf

unsigned char test_rsa_public[292] = { 0x30, 0x82, 0x01, 0x20, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
									   0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0d, 0x00, 0x30, 0x82, 0x01, 0x08, 0x02, 0x82, 0x01, 0x01,
									   0x00, 0xa2, 0x64, 0x21, 0xcf, 0x1c, 0xdb, 0x49, 0x6c, 0x44, 0x01, 0xf8, 0xd5, 0x8b, 0x8d, 0x20,
									   0xfe, 0x2a, 0x46, 0x4d, 0x29, 0xf4, 0x82, 0x3c, 0xa4, 0x29, 0x7d, 0x6b, 0xdc, 0xc4, 0x04, 0xd6,
									   0x0f, 0xf3, 0x6b, 0xa8, 0xb1, 0xad, 0x2b, 0xa1, 0xa5, 0xad, 0xfb, 0x9a, 0xba, 0x72, 0x6e, 0x4e,
									   0x71, 0x93, 0x54, 0x8d, 0x90, 0x02, 0x34, 0x80, 0x1d, 0x8c, 0x83, 0xc9, 0x84, 0xa3, 0xcf, 0x9f,
									   0x80, 0xe9, 0x4f, 0x5b, 0xf6, 0x29, 0x17, 0xf6, 0x7f, 0x5a, 0x79, 0x47, 0x0c, 0x2c, 0xcf, 0x98,
									   0x88, 0x6a, 0x31, 0x4e, 0x0a, 0x2c, 0x8e, 0x8c, 0xe5, 0xa5, 0x9f, 0xd7, 0x8f, 0xd0, 0xc1, 0x04,
									   0x1a, 0xe9, 0x54, 0xa1, 0x36, 0x4e, 0x92, 0x5e, 0x41, 0x9c, 0x07, 0xc8, 0x48, 0xac, 0x9c, 0x7c,
									   0xcb, 0xa0, 0x8a, 0x51, 0x52, 0x4f, 0x47, 0xa2, 0xc8, 0x48, 0xbc, 0xcd, 0x55, 0x85, 0x24, 0xff,
									   0xfa, 0x58, 0xe6, 0x75, 0x61, 0x14, 0x1a, 0x82, 0x4e, 0x6b, 0x40, 0x63, 0x9e, 0xef, 0xbd, 0x70,
									   0x88, 0x9e, 0xc8, 0x59, 0x89, 0x16, 0x0c, 0x4e, 0x71, 0xec, 0x2d, 0xa4, 0x0b, 0xb3, 0x20, 0xca,
									   0x04, 0x5b, 0x37, 0xf6, 0x5c, 0x80, 0x8d, 0x6a, 0xe4, 0x26, 0x95, 0xe4, 0xd5, 0x35, 0xcd, 0xd3,
									   0x90, 0x67, 0x48, 0xef, 0x14, 0x8e, 0xc6, 0xcc, 0x16, 0xdb, 0x7a, 0x96, 0xd6, 0xbf, 0x01, 0xef,
									   0x5f, 0x8d, 0xee, 0x35, 0xd1, 0x66, 0xa3, 0x26, 0x96, 0x5e, 0x73, 0x3b, 0x1e, 0xf6, 0x72, 0xc9,
									   0x78, 0xc8, 0xdd, 0x81, 0x21, 0x0f, 0x0d, 0xdc, 0x3f, 0x63, 0x7a, 0x92, 0xf1, 0x31, 0x53, 0xe6,
									   0x34, 0xd7, 0x70, 0xb0, 0x1d, 0x2f, 0x97, 0xab, 0x44, 0xf1, 0x70, 0x58, 0x0e, 0xca, 0xab, 0x26,
									   0x23, 0x39, 0x6e, 0xdb, 0xf5, 0x5a, 0x15, 0x4a, 0x09, 0x00, 0x7c, 0xe5, 0x82, 0x78, 0xb8, 0xf0,
									   0xd1, 0x02, 0x01, 0x03
									 };

unsigned char test_rsa_ca[1190] = { 0x30, 0x82, 0x04, 0xa2, 0x02, 0x01, 0x01, 0x02, 0x82, 0x01, 0x01, 0x00, 0xa5, 0x08, 0x9c, 0x9c,
									0x40, 0x75, 0x53, 0xb2, 0xd5, 0xf8, 0x48, 0xcd, 0x85, 0xef, 0x0d, 0xc3, 0xb9, 0x22, 0xa8, 0xfb,
									0x64, 0x8a, 0x00, 0x02, 0xf3, 0xe9, 0x5a, 0x77, 0x49, 0x09, 0xfa, 0x98, 0x59, 0xf7, 0x24, 0x59,
									0xff, 0x5f, 0xbf, 0x42, 0x9f, 0x8d, 0x82, 0x87, 0x7c, 0x2d, 0xc4, 0x75, 0x09, 0xab, 0x61, 0xb3,
									0x35, 0xec, 0x90, 0x48, 0x45, 0x92, 0x87, 0x6a, 0x2f, 0x29, 0xf0, 0x62, 0xb6, 0xfb, 0x9c, 0x32,
									0xd2, 0xb0, 0x50, 0xd4, 0xd7, 0x4a, 0x22, 0x32, 0x01, 0xf1, 0x3b, 0xe3, 0xf2, 0x1a, 0xde, 0xfa,
									0x20, 0x1c, 0xe9, 0x18, 0x47, 0x3c, 0x38, 0x6f, 0x47, 0x6b, 0x83, 0xbc, 0xd8, 0x04, 0x5a, 0x82,
									0x56, 0x50, 0xff, 0xc9, 0x2e, 0x1e, 0xde, 0x5a, 0xb8, 0x39, 0xec, 0x05, 0xba, 0x98, 0xae, 0x1c,
									0xe7, 0xcd, 0x83, 0x33, 0x55, 0xb6, 0xeb, 0xac, 0x99, 0xc6, 0xe2, 0x58, 0xab, 0x87, 0x48, 0x49,
									0x60, 0x92, 0xeb, 0xf3, 0xf4, 0x6d, 0xbe, 0x1d, 0x6e, 0xd4, 0xdd, 0x9a, 0x7b, 0x2c, 0xf7, 0x5c,
									0x09, 0x8e, 0xdb, 0xb3, 0x7b, 0x0d, 0x90, 0xad, 0x2d, 0x71, 0x6d, 0x42, 0x07, 0xdd, 0xd9, 0x36,
									0xd9, 0xe2, 0xeb, 0xd7, 0xde, 0x61, 0xa4, 0x81, 0x05, 0x2b, 0xbb, 0xd9, 0xa0, 0xaf, 0x75, 0x7a,
									0x85, 0xfd, 0x1c, 0x15, 0x35, 0xec, 0xf2, 0x22, 0x7f, 0x21, 0x54, 0x7c, 0x50, 0x4d, 0xfb, 0xa6,
									0x46, 0x53, 0xcd, 0x97, 0x6f, 0x9c, 0xba, 0xa8, 0x58, 0xb7, 0x65, 0x33, 0xf9, 0x60, 0xb7, 0x39,
									0xac, 0x68, 0x31, 0x7b, 0xb6, 0x58, 0xfb, 0x37, 0x21, 0xdf, 0xf6, 0x08, 0xa5, 0xec, 0xd5, 0x40,
									0x50, 0xf0, 0x2e, 0x9d, 0x8f, 0xc7, 0x1b, 0x93, 0xf5, 0xb5, 0xc9, 0xe8, 0xa2, 0x42, 0x62, 0x94,
									0xbf, 0x8d, 0xc2, 0x26, 0x8b, 0x81, 0xb3, 0xdc, 0xa3, 0x3a, 0x11, 0x8f, 0x02, 0x01, 0x03, 0x02,
									0x82, 0x01, 0x00, 0x6e, 0x05, 0xbd, 0xbd, 0x80, 0x4e, 0x37, 0xcc, 0x8e, 0xa5, 0x85, 0xde, 0x59,
									0x4a, 0x09, 0x2d, 0x26, 0x17, 0x1b, 0x52, 0x43, 0x06, 0xaa, 0xac, 0xa2, 0x9b, 0x91, 0xa4, 0xdb,
									0x5b, 0xfc, 0x65, 0x91, 0x4f, 0x6d, 0x91, 0x54, 0xea, 0x7f, 0x81, 0xbf, 0xb3, 0xac, 0x5a, 0x52,
									0xc9, 0x2d, 0xa3, 0x5b, 0xc7, 0x96, 0x77, 0x79, 0x48, 0x60, 0x30, 0x2e, 0x61, 0xaf, 0x9c, 0x1f,
									0x71, 0x4a, 0xec, 0x79, 0xfd, 0x12, 0xcc, 0x8c, 0x75, 0x8b, 0x38, 0x8f, 0x86, 0xc1, 0x76, 0xab,
									0xf6, 0x27, 0xed, 0x4c, 0x11, 0xe9, 0xfc, 0x15, 0x68, 0x9b, 0x65, 0x84, 0xd2, 0xd0, 0x4a, 0x2f,
									0x9d, 0x02, 0x7d, 0xe5, 0x58, 0x3c, 0x56, 0xe4, 0x35, 0xff, 0xdb, 0x74, 0x14, 0x94, 0x3c, 0x7a,
									0xd1, 0x48, 0x03, 0xd1, 0xbb, 0x1e, 0xbd, 0xef, 0xde, 0x57, 0x77, 0x8e, 0x79, 0xf2, 0x73, 0x11,
									0x2f, 0x41, 0x8f, 0x5f, 0xcb, 0xb7, 0x84, 0x4c, 0xdc, 0x7f, 0xec, 0x40, 0x58, 0x72, 0xf2, 0x84,
									0xed, 0x88, 0x04, 0x8a, 0xc9, 0xd0, 0x1b, 0xc3, 0xed, 0x6d, 0x88, 0xb0, 0x69, 0x76, 0x5a, 0x6e,
									0xa2, 0xb4, 0xb1, 0x34, 0x97, 0x80, 0x04, 0x96, 0x01, 0x91, 0x3e, 0x22, 0xf6, 0x7f, 0xe9, 0x82,
									0xf3, 0xee, 0x20, 0x06, 0x20, 0xc4, 0x82, 0xdd, 0x12, 0xb6, 0x4e, 0xf2, 0xcb, 0xbb, 0xaa, 0xe4,
									0x0e, 0x79, 0xe0, 0xd5, 0xe5, 0xdd, 0xe0, 0x8f, 0x7a, 0x90, 0x80, 0x9a, 0xe3, 0xc5, 0x49, 0x18,
									0x77, 0x73, 0xfb, 0xdd, 0x08, 0x18, 0x45, 0x31, 0xc9, 0xf9, 0xe2, 0x9c, 0x5d, 0x1d, 0xbd, 0x8a,
									0x32, 0xb0, 0xef, 0xf5, 0xdd, 0x7a, 0xdd, 0xa4, 0xbf, 0xd7, 0x15, 0x5b, 0x08, 0x68, 0xd9, 0xa8,
									0x33, 0xb9, 0xc0, 0xd5, 0x97, 0x64, 0xdd, 0x3c, 0x4f, 0x7e, 0x81, 0x0c, 0xb4, 0xd0, 0xcb, 0xb6,
									0xf6, 0x04, 0xcb, 0x02, 0x81, 0x81, 0x00, 0xda, 0x4d, 0x25, 0xbd, 0x16, 0x57, 0xc1, 0x75, 0xfe,
									0x6f, 0xac, 0x05, 0x2c, 0xe4, 0x75, 0x7a, 0xf5, 0xb5, 0xf9, 0xcd, 0x84, 0x6f, 0xa3, 0x84, 0x7d,
									0xa6, 0x05, 0x1f, 0xcf, 0xcd, 0x0c, 0x40, 0xe3, 0xa5, 0x8d, 0xf9, 0xcd, 0x86, 0x1b, 0x24, 0x3e,
									0x75, 0xa3, 0x8f, 0xde, 0x21, 0x23, 0x65, 0x8f, 0xd3, 0xfb, 0xb7, 0xa7, 0xc0, 0x21, 0xfb, 0x82,
									0xe2, 0x88, 0x5f, 0x22, 0x25, 0x41, 0xc2, 0x89, 0x37, 0xf6, 0xc6, 0xd7, 0xcb, 0xcc, 0xa6, 0xe3,
									0x8b, 0xb9, 0x96, 0x7c, 0xa7, 0xa5, 0x37, 0xfa, 0xec, 0xe9, 0xd2, 0xe0, 0x0a, 0x65, 0x71, 0x81,
									0x1e, 0x0d, 0xa8, 0x01, 0xdb, 0xd1, 0xbc, 0x94, 0x08, 0xb6, 0x6c, 0x51, 0xda, 0x41, 0x86, 0x05,
									0x6e, 0x5f, 0x98, 0x8f, 0x43, 0x90, 0xef, 0xcf, 0xa6, 0xd6, 0x64, 0x4e, 0xb5, 0xd2, 0xa8, 0x06,
									0x8b, 0x64, 0x5f, 0x04, 0x0b, 0x96, 0x97, 0x02, 0x81, 0x81, 0x00, 0xc1, 0x88, 0x8f, 0x45, 0xd6,
									0xf0, 0x6a, 0x9b, 0x95, 0x79, 0x65, 0xac, 0x7a, 0x8c, 0x1c, 0x18, 0xb5, 0x48, 0x45, 0x64, 0xdf,
									0x3b, 0x13, 0xe1, 0xf4, 0xc9, 0x5a, 0x05, 0xb7, 0xb0, 0x51, 0xf7, 0x55, 0x55, 0x0b, 0x36, 0x2b,
									0x5a, 0x76, 0xd6, 0x6b, 0x7a, 0x41, 0x12, 0xe2, 0x9c, 0xb3, 0x44, 0x07, 0xaa, 0x52, 0xfe, 0x92,
									0xa0, 0xe8, 0xa3, 0x46, 0xd8, 0xd0, 0x43, 0x06, 0xe6, 0x5b, 0xe8, 0x86, 0x3d, 0x38, 0x0e, 0x97,
									0x50, 0x28, 0x2f, 0xa3, 0xbb, 0x59, 0x24, 0x37, 0x5c, 0x92, 0x02, 0x32, 0xe7, 0xa8, 0xff, 0x01,
									0xae, 0xd5, 0x36, 0x4a, 0xaf, 0x40, 0xf2, 0xd0, 0xb8, 0x1a, 0xe4, 0x21, 0x17, 0xe6, 0x87, 0x87,
									0xf6, 0x2a, 0x77, 0x81, 0xcc, 0x1e, 0xb4, 0xea, 0x24, 0xa2, 0x57, 0x92, 0x38, 0x74, 0xe4, 0x96,
									0x60, 0xb1, 0xbc, 0xf1, 0xe7, 0x16, 0x4c, 0x0c, 0xbd, 0x73, 0xc9, 0x02, 0x81, 0x81, 0x00, 0x91,
									0x88, 0xc3, 0xd3, 0x64, 0x3a, 0x80, 0xf9, 0x54, 0x4a, 0x72, 0xae, 0x1d, 0xed, 0xa3, 0xa7, 0x4e,
									0x79, 0x51, 0x33, 0xad, 0x9f, 0xc2, 0x58, 0x53, 0xc4, 0x03, 0x6a, 0x8a, 0x88, 0xb2, 0xd5, 0xed,
									0x19, 0x09, 0x51, 0x33, 0xae, 0xbc, 0xc2, 0xd4, 0x4e, 0x6d, 0x0a, 0x94, 0x16, 0x17, 0x99, 0x0a,
									0x8d, 0x52, 0x7a, 0x6f, 0xd5, 0x6b, 0xfd, 0x01, 0xec, 0x5a, 0xea, 0x16, 0xc3, 0x81, 0x2c, 0x5b,
									0x7a, 0xa4, 0x84, 0x8f, 0xdd, 0x33, 0x19, 0xed, 0x07, 0xd1, 0x0e, 0xfd, 0xc5, 0x18, 0xcf, 0xfc,
									0x9d, 0xf1, 0x37, 0x40, 0x06, 0xee, 0x4b, 0xab, 0x69, 0x5e, 0x70, 0x01, 0x3d, 0x36, 0x7d, 0xb8,
									0x05, 0xce, 0xf2, 0xe1, 0x3c, 0x2b, 0xae, 0xae, 0x49, 0x95, 0x10, 0x5f, 0x82, 0x60, 0x9f, 0xdf,
									0xc4, 0x8e, 0xed, 0x89, 0xce, 0x8c, 0x70, 0x04, 0x5c, 0xed, 0x94, 0xad, 0x5d, 0x0f, 0x0f, 0x02,
									0x81, 0x81, 0x00, 0x81, 0x05, 0xb4, 0xd9, 0x39, 0xf5, 0x9c, 0x67, 0xb8, 0xfb, 0x99, 0x1d, 0xa7,
									0x08, 0x12, 0xbb, 0x23, 0x85, 0x83, 0x98, 0x94, 0xd2, 0x0d, 0x41, 0x4d, 0xdb, 0x91, 0x59, 0x25,
									0x20, 0x36, 0xa4, 0xe3, 0x8e, 0x07, 0x79, 0x72, 0x3c, 0x4f, 0x39, 0x9c, 0xfc, 0x2b, 0x61, 0xec,
									0x68, 0x77, 0x82, 0xaf, 0xc6, 0xe1, 0xff, 0x0c, 0x6b, 0x45, 0xc2, 0x2f, 0x3b, 0x35, 0x82, 0x04,
									0x99, 0x92, 0x9b, 0x04, 0x28, 0xd0, 0x09, 0xba, 0x35, 0x70, 0x1f, 0xc2, 0x7c, 0xe6, 0x18, 0x24,
									0xe8, 0x61, 0x56, 0xcc, 0x9a, 0x70, 0xaa, 0x01, 0x1f, 0x38, 0xce, 0xdc, 0x74, 0xd5, 0xf7, 0x35,
									0xd0, 0x11, 0xed, 0x6b, 0x65, 0x44, 0x5a, 0x5a, 0xa4, 0x1c, 0x4f, 0xab, 0xdd, 0x69, 0xcd, 0xf1,
									0x6d, 0xc1, 0x8f, 0xb6, 0xd0, 0x4d, 0xed, 0xb9, 0x95, 0xcb, 0xd3, 0x4b, 0xef, 0x64, 0x32, 0xb3,
									0x28, 0xf7, 0xdb, 0x02, 0x81, 0x80, 0x5d, 0xff, 0x7a, 0x4d, 0xd8, 0x6a, 0xfc, 0x24, 0xd3, 0xf7,
									0x16, 0x1d, 0x6b, 0xab, 0x6e, 0x5f, 0x2b, 0x47, 0x2c, 0xe5, 0xaf, 0x62, 0xa2, 0x1c, 0x64, 0xcc,
									0xcc, 0xe9, 0x06, 0xd2, 0xd8, 0x23, 0xbf, 0x6c, 0x9b, 0x12, 0xac, 0x51, 0x17, 0x5f, 0xba, 0x55,
									0xd6, 0xb1, 0x69, 0x92, 0x75, 0x31, 0x6c, 0xeb, 0x9b, 0x60, 0x35, 0xe1, 0xc2, 0x69, 0xec, 0x51,
									0xa8, 0x12, 0xec, 0xe6, 0x15, 0x35, 0x10, 0xfb, 0x2f, 0x94, 0x50, 0xc9, 0x6e, 0xbd, 0xf0, 0xd4,
									0x43, 0xf1, 0x2a, 0x74, 0x0b, 0x99, 0x66, 0xcd, 0xe7, 0xe0, 0x82, 0xf9, 0x20, 0x32, 0xdb, 0x13,
									0x45, 0x99, 0xa7, 0xb2, 0xf0, 0xdf, 0xa3, 0x43, 0x77, 0x01, 0x05, 0x4d, 0x14, 0xd5, 0x50, 0x40,
									0x99, 0x37, 0x7f, 0x31, 0x7b, 0x1a, 0xf3, 0x15, 0x59, 0x6a, 0x43, 0x3b, 0xb8, 0xd1, 0x29, 0xc0,
									0x35, 0x92, 0xce, 0x27, 0x94, 0x48
								  };

unsigned char test_rsa_dev[1191] = { 0x30, 0x82, 0x04, 0xa3, 0x02, 0x01, 0x01, 0x02, 0x82, 0x01, 0x01, 0x00, 0xa2, 0x64, 0x21, 0xcf,
									 0x1c, 0xdb, 0x49, 0x6c, 0x44, 0x01, 0xf8, 0xd5, 0x8b, 0x8d, 0x20, 0xfe, 0x2a, 0x46, 0x4d, 0x29,
									 0xf4, 0x82, 0x3c, 0xa4, 0x29, 0x7d, 0x6b, 0xdc, 0xc4, 0x04, 0xd6, 0x0f, 0xf3, 0x6b, 0xa8, 0xb1,
									 0xad, 0x2b, 0xa1, 0xa5, 0xad, 0xfb, 0x9a, 0xba, 0x72, 0x6e, 0x4e, 0x71, 0x93, 0x54, 0x8d, 0x90,
									 0x02, 0x34, 0x80, 0x1d, 0x8c, 0x83, 0xc9, 0x84, 0xa3, 0xcf, 0x9f, 0x80, 0xe9, 0x4f, 0x5b, 0xf6,
									 0x29, 0x17, 0xf6, 0x7f, 0x5a, 0x79, 0x47, 0x0c, 0x2c, 0xcf, 0x98, 0x88, 0x6a, 0x31, 0x4e, 0x0a,
									 0x2c, 0x8e, 0x8c, 0xe5, 0xa5, 0x9f, 0xd7, 0x8f, 0xd0, 0xc1, 0x04, 0x1a, 0xe9, 0x54, 0xa1, 0x36,
									 0x4e, 0x92, 0x5e, 0x41, 0x9c, 0x07, 0xc8, 0x48, 0xac, 0x9c, 0x7c, 0xcb, 0xa0, 0x8a, 0x51, 0x52,
									 0x4f, 0x47, 0xa2, 0xc8, 0x48, 0xbc, 0xcd, 0x55, 0x85, 0x24, 0xff, 0xfa, 0x58, 0xe6, 0x75, 0x61,
									 0x14, 0x1a, 0x82, 0x4e, 0x6b, 0x40, 0x63, 0x9e, 0xef, 0xbd, 0x70, 0x88, 0x9e, 0xc8, 0x59, 0x89,
									 0x16, 0x0c, 0x4e, 0x71, 0xec, 0x2d, 0xa4, 0x0b, 0xb3, 0x20, 0xca, 0x04, 0x5b, 0x37, 0xf6, 0x5c,
									 0x80, 0x8d, 0x6a, 0xe4, 0x26, 0x95, 0xe4, 0xd5, 0x35, 0xcd, 0xd3, 0x90, 0x67, 0x48, 0xef, 0x14,
									 0x8e, 0xc6, 0xcc, 0x16, 0xdb, 0x7a, 0x96, 0xd6, 0xbf, 0x01, 0xef, 0x5f, 0x8d, 0xee, 0x35, 0xd1,
									 0x66, 0xa3, 0x26, 0x96, 0x5e, 0x73, 0x3b, 0x1e, 0xf6, 0x72, 0xc9, 0x78, 0xc8, 0xdd, 0x81, 0x21,
									 0x0f, 0x0d, 0xdc, 0x3f, 0x63, 0x7a, 0x92, 0xf1, 0x31, 0x53, 0xe6, 0x34, 0xd7, 0x70, 0xb0, 0x1d,
									 0x2f, 0x97, 0xab, 0x44, 0xf1, 0x70, 0x58, 0x0e, 0xca, 0xab, 0x26, 0x23, 0x39, 0x6e, 0xdb, 0xf5,
									 0x5a, 0x15, 0x4a, 0x09, 0x00, 0x7c, 0xe5, 0x82, 0x78, 0xb8, 0xf0, 0xd1, 0x02, 0x01, 0x03, 0x02,
									 0x82, 0x01, 0x00, 0x6c, 0x42, 0xc1, 0x34, 0xbd, 0xe7, 0x86, 0x48, 0x2d, 0x56, 0xa5, 0xe3, 0xb2,
									 0x5e, 0x15, 0xfe, 0xc6, 0xd9, 0x88, 0xc6, 0xa3, 0x01, 0x7d, 0xc2, 0xc6, 0x53, 0x9d, 0x3d, 0xd8,
									 0x03, 0x39, 0x5f, 0xf7, 0x9d, 0x1b, 0x21, 0x1e, 0x1d, 0x16, 0x6e, 0x73, 0xfd, 0x11, 0xd1, 0xa1,
									 0x9e, 0xde, 0xf6, 0x62, 0x38, 0x5e, 0x60, 0x01, 0x78, 0x55, 0x69, 0x08, 0x57, 0xdb, 0xad, 0xc2,
									 0x8a, 0x6a, 0x55, 0xf0, 0xdf, 0x92, 0xa4, 0x1b, 0x65, 0x4e, 0xff, 0x91, 0xa6, 0x2f, 0x5d, 0x73,
									 0x35, 0x10, 0x5a, 0xf1, 0x76, 0x34, 0x06, 0xc8, 0x5f, 0x08, 0x99, 0x19, 0x15, 0x3a, 0x5f, 0xe0,
									 0x80, 0xad, 0x67, 0x46, 0x38, 0x6b, 0x79, 0x89, 0xb6, 0xe9, 0x81, 0x12, 0xaf, 0xda, 0xdb, 0x1d,
									 0xbd, 0xa8, 0x87, 0xc0, 0x5c, 0x36, 0x36, 0xdf, 0x85, 0x17, 0x30, 0x30, 0x7d, 0xde, 0x39, 0x03,
									 0x6d, 0xff, 0xfb, 0x2b, 0x5d, 0x42, 0x90, 0x42, 0x03, 0x55, 0xf6, 0xd1, 0xc3, 0xdd, 0x2c, 0xe5,
									 0x94, 0x83, 0xf7, 0x35, 0xb8, 0x05, 0xcd, 0xf5, 0xa5, 0xe6, 0x3b, 0xd1, 0xd2, 0x49, 0xe2, 0xbe,
									 0x58, 0x7b, 0x6c, 0xc7, 0xd5, 0xf7, 0x36, 0xe4, 0x00, 0xa4, 0xd6, 0xe9, 0xf6, 0x62, 0x19, 0x36,
									 0x58, 0xfb, 0xb4, 0x17, 0x0e, 0x97, 0x9a, 0xba, 0xaa, 0x7d, 0xbd, 0x90, 0xf5, 0x2c, 0x39, 0xeb,
									 0x86, 0x26, 0xd5, 0xea, 0xbd, 0xcf, 0xf4, 0x8f, 0x5a, 0xa6, 0x76, 0xde, 0xa7, 0x70, 0x2f, 0x1a,
									 0x1e, 0xff, 0x40, 0x39, 0x4d, 0xc0, 0x9f, 0xaa, 0x0a, 0x99, 0x08, 0x68, 0x97, 0x96, 0xb1, 0xb7,
									 0x36, 0xe1, 0x46, 0xd5, 0xd6, 0xd0, 0xd1, 0x8f, 0x23, 0x52, 0x19, 0xb8, 0xfd, 0xd1, 0x47, 0xf4,
									 0xb2, 0x0d, 0x99, 0xb7, 0x7a, 0xd2, 0x57, 0x01, 0xde, 0x36, 0x69, 0x53, 0x9f, 0xb6, 0x56, 0xa0,
									 0x61, 0x89, 0x4b, 0x02, 0x81, 0x81, 0x00, 0xcf, 0xac, 0xb0, 0x32, 0xdc, 0xa1, 0x1a, 0xb7, 0xc6,
									 0xe3, 0xb8, 0xde, 0x0a, 0x70, 0x4b, 0xfa, 0x59, 0xa2, 0x0b, 0x6b, 0x2b, 0xe6, 0x5c, 0xd6, 0xe4,
									 0xc8, 0xc9, 0xe5, 0xe8, 0xb7, 0xa5, 0xa3, 0x94, 0xcb, 0x55, 0x74, 0x4e, 0xfe, 0xdf, 0x82, 0x97,
									 0xd0, 0x36, 0xee, 0x00, 0x03, 0x8e, 0x86, 0x28, 0xa1, 0x10, 0xd5, 0xf9, 0x91, 0x0b, 0x7a, 0x3f,
									 0x4e, 0x11, 0xdc, 0x44, 0x39, 0xbe, 0xc2, 0x4c, 0x10, 0xaf, 0x76, 0xa4, 0xe2, 0xf6, 0xd2, 0x5a,
									 0x59, 0x69, 0xbb, 0x42, 0xb4, 0x65, 0x50, 0xc8, 0xd8, 0x18, 0x44, 0x55, 0x26, 0x66, 0x8d, 0xd4,
									 0x6e, 0x9d, 0x42, 0xe7, 0xac, 0x44, 0x3a, 0x4b, 0x4d, 0x71, 0x46, 0x94, 0x05, 0x19, 0x9b, 0x8f,
									 0xdc, 0x25, 0x06, 0xef, 0x00, 0xd2, 0xd5, 0x78, 0xe8, 0xf0, 0x9e, 0xdd, 0x2f, 0xf6, 0xa8, 0x54,
									 0xdf, 0xb7, 0x34, 0xe3, 0x5d, 0xc9, 0x55, 0x02, 0x81, 0x81, 0x00, 0xc8, 0x2d, 0xe1, 0x55, 0xd4,
									 0x74, 0x66, 0xa4, 0x69, 0xb6, 0xde, 0xfd, 0x8c, 0xee, 0x5e, 0x9b, 0x74, 0x92, 0x45, 0x68, 0xf9,
									 0xad, 0x18, 0x41, 0x4c, 0xa9, 0x6b, 0x51, 0xac, 0xe4, 0x6b, 0x3d, 0x9a, 0xab, 0xae, 0x15, 0xdb,
									 0x8d, 0x94, 0x1f, 0x2f, 0xd4, 0x1a, 0xc1, 0x64, 0x44, 0xcb, 0x7c, 0x1c, 0x11, 0xfa, 0xd6, 0x7d,
									 0x36, 0x04, 0x00, 0x42, 0xbc, 0xc2, 0xa3, 0x99, 0x7e, 0xf6, 0x5c, 0x61, 0xc0, 0xce, 0x6b, 0xea,
									 0xb8, 0x36, 0x11, 0xb6, 0x1e, 0xa9, 0x1d, 0x0c, 0x8f, 0xe5, 0x47, 0xaa, 0x10, 0xc7, 0xed, 0x3a,
									 0xd7, 0x90, 0x24, 0xf2, 0x28, 0x93, 0xa3, 0xb6, 0xd5, 0x50, 0x10, 0x4b, 0x61, 0x05, 0x9c, 0x44,
									 0xdd, 0x96, 0x82, 0xcc, 0x17, 0x79, 0x1b, 0xec, 0x9f, 0x3e, 0xe7, 0x2d, 0x4d, 0xaf, 0xd3, 0xfa,
									 0x18, 0x01, 0xc2, 0xae, 0x2d, 0x9c, 0xcb, 0xa4, 0xc8, 0xd9, 0x8d, 0x02, 0x81, 0x81, 0x00, 0x8a,
									 0x73, 0x20, 0x21, 0xe8, 0x6b, 0x67, 0x25, 0x2f, 0x42, 0x7b, 0x3e, 0xb1, 0xa0, 0x32, 0xa6, 0xe6,
									 0x6c, 0x07, 0x9c, 0xc7, 0xee, 0xe8, 0x8f, 0x43, 0x30, 0x86, 0x99, 0x45, 0xcf, 0xc3, 0xc2, 0x63,
									 0x32, 0x38, 0xf8, 0x34, 0xa9, 0xea, 0x57, 0x0f, 0xe0, 0x24, 0x9e, 0xaa, 0xad, 0x09, 0xae, 0xc5,
									 0xc0, 0xb5, 0xe3, 0xfb, 0xb6, 0x07, 0xa6, 0xd4, 0xde, 0xb6, 0x92, 0xd8, 0x26, 0x7f, 0x2c, 0x32,
									 0xb5, 0xca, 0x4f, 0x18, 0x97, 0x4f, 0x36, 0xe6, 0xe6, 0x46, 0x7c, 0xd7, 0x22, 0xee, 0x35, 0xdb,
									 0x3a, 0xba, 0xd8, 0x38, 0xc4, 0x44, 0x5e, 0x8d, 0x9f, 0x13, 0x81, 0xef, 0xc8, 0x2d, 0x7c, 0x32,
									 0x33, 0xa0, 0xd9, 0xb8, 0x03, 0x66, 0x67, 0xb5, 0x3d, 0x6e, 0x04, 0x9f, 0x55, 0xe1, 0xe3, 0xa5,
									 0xf0, 0xa0, 0x69, 0xe8, 0xca, 0xa4, 0x70, 0x38, 0x95, 0x24, 0xcd, 0xec, 0xe9, 0x30, 0xe3, 0x02,
									 0x81, 0x81, 0x00, 0x85, 0x73, 0xeb, 0x8e, 0x8d, 0xa2, 0xef, 0x18, 0x46, 0x79, 0xe9, 0xfe, 0x5d,
									 0xf4, 0x3f, 0x12, 0x4d, 0xb6, 0xd8, 0xf0, 0xa6, 0x73, 0x65, 0x80, 0xdd, 0xc6, 0x47, 0x8b, 0xc8,
									 0x98, 0x47, 0x7e, 0x67, 0x1d, 0x1e, 0xb9, 0x3d, 0x09, 0x0d, 0x6a, 0x1f, 0xe2, 0xbc, 0x80, 0xed,
									 0x83, 0x32, 0x52, 0xbd, 0x61, 0x51, 0xe4, 0x53, 0x79, 0x58, 0x00, 0x2c, 0x7d, 0xd7, 0x17, 0xbb,
									 0xa9, 0xf9, 0x92, 0xeb, 0xd5, 0xde, 0xf2, 0x9c, 0x7a, 0xce, 0xb6, 0x79, 0x69, 0xc6, 0x13, 0x5d,
									 0xb5, 0x43, 0x85, 0x1c, 0x0b, 0x2f, 0xf3, 0x7c, 0x8f, 0xb5, 0x6d, 0xf6, 0xc5, 0xb7, 0xc2, 0x79,
									 0xe3, 0x8a, 0xb5, 0x87, 0x96, 0x03, 0xbd, 0x83, 0x3e, 0x64, 0x57, 0x32, 0xba, 0x50, 0xbd, 0x48,
									 0x6a, 0x29, 0xef, 0x73, 0x89, 0x1f, 0xe2, 0xa6, 0xba, 0xab, 0xd7, 0x1e, 0xc9, 0x13, 0x32, 0x6d,
									 0xdb, 0x3b, 0xb3, 0x02, 0x81, 0x81, 0x00, 0xa9, 0xe4, 0xa3, 0x54, 0x03, 0x2f, 0xc2, 0x8d, 0xa2,
									 0x1e, 0xae, 0xe0, 0xfb, 0xe9, 0xba, 0xe0, 0xb5, 0xb6, 0x69, 0x0d, 0xe3, 0x8e, 0xeb, 0x0a, 0x29,
									 0x9d, 0x15, 0xc2, 0x8a, 0x76, 0x96, 0x4e, 0x77, 0xea, 0x1a, 0x0b, 0xe8, 0x9b, 0x5d, 0xf7, 0xbd,
									 0x86, 0xfb, 0xe4, 0x6b, 0x3c, 0x32, 0xc6, 0x7a, 0xfe, 0xf7, 0x5f, 0xec, 0x2e, 0x24, 0xfa, 0x68,
									 0xac, 0xf2, 0xa5, 0x32, 0x4d, 0xd8, 0xd3, 0x68, 0xfa, 0xde, 0xcc, 0x37, 0x38, 0xa8, 0x3b, 0x4e,
									 0xeb, 0xae, 0x25, 0xca, 0xb7, 0xc0, 0x80, 0x70, 0x58, 0xea, 0xc3, 0x52, 0xaa, 0x24, 0x3c, 0x24,
									 0x17, 0x47, 0x37, 0x70, 0xf9, 0x45, 0x83, 0x20, 0xce, 0x92, 0xe2, 0x6b, 0x58, 0xfd, 0xa2, 0x90,
									 0x5b, 0x68, 0x4c, 0x7e, 0x1a, 0x9b, 0xcd, 0x94, 0xef, 0x4b, 0xe8, 0x8d, 0x9b, 0xf8, 0x38, 0x6e,
									 0x1e, 0x12, 0xa5, 0xaf, 0xd3, 0xf0, 0xbd
								   };

unsigned char test_ecdsa_dev_bp[122] = { 0x30, 0x78, 0x02, 0x01, 0x01, 0x04, 0x20, 0x1e, 0x20, 0xd3, 0xa6, 0xaa, 0x38, 0xf6, 0xf1, 0x65,
										 0x19, 0xb8, 0xae, 0x31, 0x86, 0x7a, 0x47, 0x3b, 0xaf, 0x5e, 0x54, 0x93, 0xb1, 0x46, 0xba, 0x8d,
										 0x39, 0x25, 0xa9, 0xe4, 0xd2, 0x41, 0x66, 0xa0, 0x0b, 0x06, 0x09, 0x2b, 0x24, 0x03, 0x03, 0x02,
										 0x08, 0x01, 0x01, 0x07, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x1a, 0xbc, 0xb3, 0x24, 0xa4, 0x1e,
										 0x89, 0x79, 0x6e, 0xbe, 0x75, 0x7f, 0x78, 0xa7, 0x32, 0x21, 0xae, 0x7b, 0xb5, 0xe4, 0xa4, 0x4d,
										 0x07, 0x44, 0x0e, 0x07, 0x5a, 0x77, 0x3d, 0xb3, 0xd8, 0xfc, 0x65, 0x02, 0xfc, 0xd7, 0x1a, 0x3c,
										 0xcb, 0x9a, 0x4e, 0x34, 0xde, 0x32, 0xe8, 0x3e, 0x2e, 0xda, 0x09, 0xe0, 0x5f, 0x24, 0x7b, 0x86,
										 0x83, 0x08, 0xc3, 0xf6, 0x7f, 0xe3, 0x81, 0xbb, 0xda, 0x62
									   };

unsigned char test_ecdsa_dev_nist[223] = { 0x30, 0x81, 0xdc, 0x02, 0x01, 0x01, 0x04, 0x42, 0x00, 0x94, 0x4f, 0x20, 0xa2, 0x5b, 0x75, 0xcb,
										   0x2d, 0xc6, 0x17, 0xd1, 0xd9, 0x04, 0xb5, 0x19, 0x4b, 0xfd, 0x80, 0x8f, 0xd8, 0x6f, 0xc0, 0x23,
										   0x2f, 0x23, 0x90, 0xe8, 0x29, 0xa9, 0x9e, 0x28, 0x0b, 0x8d, 0xa8, 0xf2, 0xb5, 0x4a, 0x7d, 0xc8,
										   0x09, 0x79, 0xb7, 0xb4, 0xc4, 0x6e, 0xb4, 0x95, 0x35, 0xbe, 0xcd, 0x19, 0x96, 0x9b, 0x3c, 0xae,
										   0x50, 0x2c, 0x98, 0x77, 0x47, 0x0c, 0x7f, 0x87, 0x3b, 0xbd, 0xa0, 0x07, 0x06, 0x05, 0x2b, 0x81,
										   0x04, 0x00, 0x23, 0xa1, 0x81, 0x89, 0x03, 0x81, 0x86, 0x00, 0x04, 0x00, 0xa7, 0xe3, 0x75, 0x81,
										   0x42, 0x82, 0x15, 0x7c, 0x36, 0xff, 0x46, 0x43, 0x78, 0x9f, 0x94, 0x99, 0x5c, 0xba, 0x59, 0x90,
										   0xdc, 0x2a, 0xed, 0x90, 0xbb, 0x87, 0x07, 0x99, 0x69, 0x17, 0xa5, 0x1d, 0x38, 0x71, 0xc9, 0x91,
										   0x0e, 0x9c, 0xa6, 0x35, 0x30, 0x91, 0x1e, 0x98, 0x07, 0x5c, 0xfd, 0xe2, 0x8c, 0x44, 0x16, 0xc3,
										   0xc4, 0x2b, 0x03, 0xf0, 0x3b, 0xd7, 0xdc, 0x26, 0xcb, 0x82, 0xe5, 0xcd, 0x47, 0x01, 0xc3, 0x01,
										   0xa9, 0xd6, 0xe3, 0xe3, 0x65, 0x4a, 0x8d, 0x23, 0xff, 0xb4, 0xaa, 0xa6, 0x32, 0x30, 0x63, 0x8c,
										   0x31, 0x1a, 0x83, 0xa7, 0xd6, 0xd1, 0xf1, 0xd2, 0x50, 0xbf, 0xd5, 0x51, 0x3b, 0x74, 0x13, 0x71,
										   0x79, 0x1b, 0x55, 0x34, 0x2b, 0xae, 0x98, 0x40, 0x32, 0xcc, 0xf4, 0xae, 0xc5, 0xe3, 0xd3, 0x03,
										   0xcf, 0x8f, 0x36, 0xeb, 0x2c, 0xc8, 0x0a, 0xc7, 0xad, 0x88, 0x24, 0x9f, 0x00, 0xd4, 0x18
										 };

unsigned int TC_see_read_write_secure_storage(void)
{
	int j = 0;
	int ret = 0;
	unsigned int test_result = 0;
	unsigned char input[300];
	unsigned int inlen[3] = { 18, SEE_MAX_DATA_SIZE, SEE_MAX_DATA_SIZE + 1 };
	unsigned char output[SEE_MAX_DATA_SIZE];

	printf("--------------------------------------------\n");
	printf("  TESTCASE : see_read/write_secure_storage\n");
	printf("--------------------------------------------\n");

	memset(input, 1, 300);

	for (j = 0; j < SSTORAGE_DATA_SLOT_INDEX_MAX; j++) {
		see_selfprintf("[%d] ", j);

		/* positive case 1 */
		memset(output, 0, SEE_MAX_DATA_SIZE);
		ret = see_write_secure_storage(input, inlen[0], j);
		if (ret != SEE_OK) {
			test_result |= 0x1;
			see_selfprintf("SS write fail\n");
			break;
		}

		ret = see_read_secure_storage(output, &inlen[0], j);
		if (ret != SEE_OK) {
			test_result |= 0x1;
			see_selfprintf("SS read fail\n");
			break;
		}

		if (memcmp(input, output, inlen[0]) != 0) {
			test_result |= 0x1;
			see_selfprintf(" fail\n");
			break;
		}

		/* positive case 2 */
		memset(output, 0, SEE_MAX_DATA_SIZE);
		ret = see_write_secure_storage(input, inlen[1], j);
		if (ret != SEE_OK) {
			test_result |= 0x1;
			see_selfprintf("SS write fail\n");
			break;
		}

		ret = see_read_secure_storage(output, &inlen[1], j);
		if (ret != SEE_OK) {
			test_result |= 0x1;
			see_selfprintf("SS read fail\n");
			break;
		}

		if (memcmp(input, output, inlen[1]) != 0) {
			test_result |= 0x1;
			see_selfprintf(" fail\n");
			break;
		}

		/* negative case 1 : exceed max size */
		memset(output, 0, SEE_MAX_DATA_SIZE);
		ret = see_write_secure_storage(input, inlen[2], j);
		if (ret == SEE_OK) {
			test_result |= 0x1;
			see_selfprintf("Negative TC write fail\n");
			break;
		}

		ret = see_read_secure_storage(output, &inlen[2], j);
		if (ret != SEE_OK) {
			test_result |= 0x1;
			see_selfprintf("Negative TC read fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}

		inlen[0] = 18;
		inlen[1] = SEE_MAX_DATA_SIZE;
		inlen[2] = SEE_MAX_DATA_SIZE + 1;
	}

	see_selfprintf("[%d] ", j);

	return test_result;
}

#define SEE_GENERATE_KEY_TC 16

unsigned int TC_see_generate_key(void)
{
	int ret = 0;
	int i = 0;
	int j = 0;
	unsigned int test_result = 0;

	printf("----------------------------------------\n");
	printf("TESTCASE : see_generate_key\n");
	printf("----------------------------------------\n");

	// Positive Case
	unsigned int genkey_input[SEE_GENERATE_KEY_TC][3] = {
		{AES_KEY, 16, SEE_OK}, {AES_KEY, 24, SEE_OK}, {AES_KEY, 32, SEE_OK},
		{AES_KEY, 48, SEE_OK}, {AES_KEY, 64, SEE_OK}, {HMAC_KEY, 64, SEE_OK},
		{HMAC_KEY, 128, SEE_OK}, {ECC_KEY_BP256, 0, SEE_OK}, {ECC_KEY_NIST192, 0, SEE_OK},
		{ECC_KEY_NIST224, 0, SEE_OK}, {ECC_KEY_NIST256, 0, SEE_OK}, {ECC_KEY_NIST384, 0, SEE_OK},
		{ECC_KEY_NIST512, 0, SEE_OK}, {AES_KEY, 80, SEE_ERROR}, {HMAC_KEY, 129, SEE_ERROR},
		{0xffff, 0, SEE_INVALID_INPUT_PARAMS}
	};

	for (j = 0; j < SEE_GENERATE_KEY_TC; j++) {
		for (i = 0; i < SEE_MAX_KEY_INDEX; i++) {
			see_selfprintf("[%d] ", j * SEE_MAX_KEY_INDEX + i);
			ret = see_generate_key(genkey_input[j][0], i, genkey_input[j][1], 0);
			if (ret != genkey_input[j][2]) {
				test_result |= 0x4;
				see_selfprintf(" fail\n");
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	isp_clear(0);

	unsigned int genkey_input_rsa[4][2] = { {RSA_KEY_1024, 17}, {RSA_KEY_2048, 17},
		{RSA_KEY_1024, 0}, {RSA_KEY_2048, 0}
	};

	for (j = 0; j < 4; j++) {
		see_selfprintf("[%d] ", j);
		ret = see_generate_key(genkey_input_rsa[j][0], 0, 0, genkey_input_rsa[j][1]);
		if (ret != SEE_OK) {
			test_result |= 0x4;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}

	isp_clear(0);

	// Negative Case
	for (j = 0; j < SEE_GENERATE_KEY_TC - 1; j++) {
		see_selfprintf("[%d] ", SEE_GENERATE_KEY_TC * SEE_MAX_KEY_INDEX + j);
		ret = see_generate_key(genkey_input[j][0], SEE_MAX_KEY_INDEX, genkey_input[j][1], 0);
		if (ret == genkey_input[j][2]) {
			test_result |= 0x4;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}
	ret = see_generate_key(genkey_input[SEE_GENERATE_KEY_TC - 1][0], SEE_MAX_KEY_INDEX, genkey_input[SEE_GENERATE_KEY_TC - 1][1], 0);
	if (ret != genkey_input[j][2]) {
		test_result |= 0x4;
		see_selfprintf(" fail\n");
	} else {
		see_selfprintf(" success\n");
	}

	isp_clear(0);

	return test_result;
}

unsigned int TC_see_setup_remove_key(void)
{
	int ret = 0;
	int i = 0;
	int j = 0;
	unsigned int test_result = 0;
	unsigned int key_size[5] = { 32, 128, 1212, 1212, 256 };
	unsigned int key_type[5] = { SECURE_STORAGE_TYPE_KEY_AES,
								 SECURE_STORAGE_TYPE_KEY_HMAC, SECURE_STORAGE_TYPE_KEY_RSA,
								 SECURE_STORAGE_TYPE_KEY_DH, SECURE_STORAGE_TYPE_KEY_ECC
							   };

	unsigned char *key = (unsigned char *)malloc(1280 * sizeof(unsigned char));
	if (!key) {
		test_result |= 0x8;
		goto error_out;
	}

	printf("----------------------------------------\n");
	printf("TESTCASE : see_setup/remove_key\n");
	printf("----------------------------------------\n");

	memset(key, 0xa5, 1280);

	for (i = 0; i < 5; i++) {
		for (j = 0; j < 9; j++) {
			see_selfprintf("[%d] ", j + i * 9);

			ret = see_setup_key(key, key_size[i], key_type[i], j);
			ret += see_remove_key(j, key_type[i]);
			if (j == 8 && ret) {
				see_selfprintf(" success\n");
			} else if (ret) {
				test_result |= 0x8;
				see_selfprintf(" fail\n");
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	free(key);
error_out:
	isp_clear(0);
	return test_result;
}

unsigned int TC_see_aes_encrypt_decrypt(void)
{
	int ret = 0;
	int i = 0;
	int j = 0;
	unsigned int test_result = 0;
	struct sAES_PARAM aes_param;
	unsigned int aes_size[2] = { 16, 32 };
	unsigned char aes_input[150] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
									 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
									 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
									 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0,
									 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
								   };
	unsigned char aes_output[150];
	unsigned char aes_check[150];

	printf("----------------------------------------\n");
	printf("TESTCASE : see_aes_encrypt/decrypt\n");
	printf("----------------------------------------\n");

	memset(&aes_param, 0, sizeof(struct sAES_PARAM));

	for (i = 0; i < 2; i++) {
		for (j = 0; j < 8; j++) {
			see_selfprintf("[%d] ", j + i * 8);

			aes_param.pu8Plaintext = aes_input;
			aes_param.u32Plaintext_byte_len = aes_size[i];
			aes_param.pu8Ciphertext = aes_output;
			aes_param.u32Ciphertext_byte_len = aes_size[i];
			aes_param.u32Mode = AES_ECB_MODE;

			ret = see_setup_key(aes_input, aes_size[i], SECURE_STORAGE_TYPE_KEY_AES, j);
			ret += see_aes_encrypt(j, &aes_param);

			aes_param.pu8Plaintext = aes_param.pu8Ciphertext;
			aes_param.pu8Ciphertext = aes_check;
			ret += see_aes_decrypt(j, &aes_param);

			if (ret || memcmp(aes_input, aes_check, aes_size[i])) {
				test_result |= 0x10;
				see_selfprintf(" fail\n");
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	isp_clear(0);
	return test_result;
}

#define SEE_GET_HASH_TC 8
unsigned int TC_see_get_hash(void)
{
	int ret = 0;
	int i = 0;
	unsigned int test_result = 0;
	struct sHASH_MSG h_param;
	unsigned char input[300];
	unsigned char output[200];
	unsigned int hash_type[SEE_GET_HASH_TC] = { SHA1_160, SHA2_256, SHA2_384, SHA2_512,
												SHA3_224, SHA3_256, SHA3_384, SHA3_512
											  };

	printf("----------------------------------------\n");
	printf("TESTCASE : see_get_hash\n");
	printf("----------------------------------------\n");

	memset(&h_param, 0, sizeof(struct sHASH_MSG));

	h_param.addr_low = (unsigned int)input;
	h_param.msg_byte_len = 300;

	for (i = 0; i < SEE_GET_HASH_TC; i++) {
		see_selfprintf("[%d] ", i);
		ret = see_get_hash(&h_param, output, hash_type[i]);

		if (ret) {
			test_result |= 0x20;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}

	}

	isp_clear(0);
	return test_result;
}

#define SEE_GENERATE_RANDOM_TC 8
unsigned int TC_see_get_random(void)
{
	int i = 0;
	int ret = 0;
	unsigned int input[300];
	unsigned int test_result = 0;
	unsigned int random_size[SEE_GENERATE_RANDOM_TC] = { 0, 10, 20, 30, 40, 50, 256, 257 };
	unsigned int expect_result[SEE_GENERATE_RANDOM_TC] = { 0, 0, 0, 0, 0, 0, 0, SEE_INVALID_INPUT_PARAMS };

	printf("----------------------------------------\n");
	printf("TESTCASE : see_get_random\n");
	printf("----------------------------------------\n");

	for (i = 0; i < SEE_GENERATE_RANDOM_TC; i++) {
		printf("[%d] ", i);

		ret = see_generate_random((unsigned int *)input, random_size[i]);

		if (ret != expect_result[i]) {
			test_result |= 0x40;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_get_hmac(void)
{
	int ret = 0;
	int i = 0;
	int j = 0;
	unsigned int test_result = 0;
	struct sHMAC_MSG hmac_msg;
	unsigned char input_hmac[300];
	unsigned char output_hmac[200];
	unsigned int input_oid[5] = { HMAC_SHA1_160, HMAC_SHA2_256, HMAC_SHA2_384, HMAC_SHA2_512, 1 };
	unsigned int expect_result[5] = { 0, 0, 0, 0, SEE_ERROR };

	printf("----------------------------------------\n");
	printf("TESTCASE : see_get_hmac\n");
	printf("----------------------------------------\n");

	hmac_msg.addr_low = (unsigned int)input_hmac;
	hmac_msg.msg_byte_len = 300;

	for (i = 0; i < 5; i++) {
		for (j = 0; j < 8; j++) {
			see_selfprintf("[%d] ", j + i * 8);

			ret = see_setup_key(input_hmac, 64, SECURE_STORAGE_TYPE_KEY_HMAC, j);
			ret += see_get_hmac(&hmac_msg, output_hmac, input_oid[i], j);

			if (ret != expect_result[i]) {
				test_result |= 0x80;
				see_selfprintf(" fail\n");
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_generate_certificate(void)
{
	int ret = 0;
	int i = 0;
	unsigned int test_result = 0;

	printf("----------------------------------------\n");
	printf("TESTCASE : see_generate_certificate\n");
	printf("----------------------------------------\n");

	struct cert_opt c_opt;
	unsigned int c_buflen = 2000, c_bufoutlen = 2000;
	unsigned char *c_buf = (unsigned char *)malloc(c_buflen * sizeof(unsigned char));
	if (!c_buf) {
		test_result |= 0x100;
		see_selfprintf(" c_buf malloc fail\n");
		return test_result;
	}
	unsigned char *c_buf_out = (unsigned char *)malloc(c_bufoutlen * sizeof(unsigned char));
	if (!c_buf_out) {
		test_result |= 0x100;
		see_selfprintf(" c_buf_out malloc fail\n");
		return test_result;
	}
	memset(&c_opt, 0, sizeof(struct cert_opt));

	ret = see_setup_key(test_rsa_ca, sizeof(test_rsa_ca), SECURE_STORAGE_TYPE_KEY_RSA, 1);
	ret += see_setup_key(test_rsa_dev, sizeof(test_rsa_dev), SECURE_STORAGE_TYPE_KEY_RSA, 2);
	c_opt.cert_index = SEE_MIN_CERT_INDEX;
	c_opt.issuer_key_index = 1;
	c_opt.subject_key_index = 2;

	c_opt.subject_pub_key = test_rsa_public;
	c_opt.subject_pub_keylen = sizeof(test_rsa_public);

	ret += see_generate_certificate(c_opt, c_buf, &c_buflen);

	if (ret) {
		test_result |= 0x100;
		see_selfprintf(" fail\n");
		return test_result;
	} else {
		see_selfprintf(" success\n");
	}

	isp_clear(0);

	printf("----------------------------------------\n");
	printf("  TESTCASE : see_set/get_certificate\n");
	printf("----------------------------------------\n");

	for (i = SEE_MIN_CERT_INDEX; i < SEE_MAX_CERT_INDEX + 1; i++) {
		see_selfprintf("[%d] ", i);

		c_bufoutlen = 2000;

		ret = see_set_certificate(c_buf, c_buflen, i, CERT_PEM);
		ret += see_get_certificate(c_buf_out, &c_bufoutlen, i, CERT_PEM);

		if (i == SEE_MAX_CERT_INDEX && ret) {
			see_selfprintf(" success\n");
		} else if (ret || c_buflen != c_bufoutlen || memcmp(c_buf, c_buf_out, c_buflen)) {
			test_result |= 0x100;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}

	free(c_buf);
	free(c_buf_out);

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_generate_dhm_params(void)
{
	unsigned int test_result = 0;
	int ret = 1;
	int i = 0;
	struct sDH_PARAM d_param;
	unsigned char p_buf_1024[] = {
		0xb1, 0x0b, 0x8f, 0x96, 0xa0, 0x80, 0xe0, 0x1d, 0xde, 0x92, 0xde, 0x5e, 0xae,
		0x5d, 0x54, 0xec, 0x52, 0xc9, 0x9f, 0xbc, 0xfb, 0x06, 0xa3, 0xc6, 0x9a, 0x6a,
		0x9d, 0xca, 0x52, 0xd2, 0x3b, 0x61, 0x60, 0x73, 0xe2, 0x86, 0x75, 0xa2, 0x3d,
		0x18, 0x98, 0x38, 0xef, 0x1e, 0x2e, 0xe6, 0x52, 0xc0, 0x13, 0xec, 0xb4, 0xae,
		0xa9, 0x06, 0x11, 0x23, 0x24, 0x97, 0x5c, 0x3c, 0xd4, 0x9b, 0x83, 0xbf, 0xac,
		0xcb, 0xdd, 0x7d, 0x90, 0xc4, 0xbd, 0x70, 0x98, 0x48, 0x8e, 0x9c, 0x21, 0x9a,
		0x73, 0x72, 0x4e, 0xff, 0xd6, 0xfa, 0xe5, 0x64, 0x47, 0x38, 0xfa, 0xa3, 0x1a,
		0x4f, 0xf5, 0x5b, 0xcc, 0xc0, 0xa1, 0x51, 0xaf, 0x5f, 0x0d, 0xc8, 0xb4, 0xbd,
		0x45, 0xbf, 0x37, 0xdf, 0x36, 0x5c, 0x1a, 0x65, 0xe6, 0x8c, 0xfd, 0xa7, 0x6d,
		0x4d, 0xa7, 0x08, 0xdf, 0x1f, 0xb2, 0xbc, 0x2e, 0x4a, 0x43, 0x71
	};

	unsigned char g_buf_1024[] = { 0xa4, 0xd1, 0xcb, 0xd5, 0xc3, 0xfd, 0x34, 0x12, 0x67, 0x65, 0xa4, 0x42, 0xef, 0xb9, 0x99,
								   0x05, 0xf8, 0x10, 0x4d, 0xd2, 0x58, 0xac, 0x50, 0x7f, 0xd6, 0x40, 0x6c, 0xff, 0x14, 0x26,
								   0x6d, 0x31, 0x26, 0x6f, 0xea, 0x1e, 0x5c, 0x41, 0x56, 0x4b, 0x77, 0x7e, 0x69, 0x0f, 0x55,
								   0x04, 0xf2, 0x13, 0x16, 0x02, 0x17, 0xb4, 0xb0, 0x1b, 0x88, 0x6a, 0x5e, 0x91, 0x54, 0x7f,
								   0x9e, 0x27, 0x49, 0xf4, 0xd7, 0xfb, 0xd7, 0xd3, 0xb9, 0xa9, 0x2e, 0xe1, 0x90, 0x9d, 0x0d,
								   0x22, 0x63, 0xf8, 0x0a, 0x76, 0xa6, 0xa2, 0x4c, 0x08, 0x7a, 0x09, 0x1f, 0x53, 0x1d, 0xbf,
								   0x0a, 0x01, 0x69, 0xb6, 0xa2, 0x8a, 0xd6, 0x62, 0xa4, 0xd1, 0x8e, 0x73, 0xaf, 0xa3, 0x2d,
								   0x77, 0x9d, 0x59, 0x18, 0xd0, 0x8b, 0xc8, 0x85, 0x8f, 0x4d, 0xce, 0xf9, 0x7c, 0x2a, 0x24,
								   0x85, 0x5e, 0x6e, 0xeb, 0x22, 0xb3, 0xb2, 0xe5
								 };

	unsigned char p_buf_2048[] = { 0xf9, 0x34, 0xf4, 0x6b, 0x82, 0x64, 0xda, 0xd1, 0x86, 0xc0, 0xbc, 0x22, 0xd0, 0xc0,
								   0x73, 0xaa, 0xf4, 0x22, 0x5d, 0x36, 0x8b, 0x82, 0x7e, 0xce, 0x84, 0x5e, 0x42, 0x6f,
								   0x1e, 0x75, 0x4d, 0xdd, 0x12, 0x2a, 0x2b, 0xb6, 0x1a, 0x30, 0x5f, 0xa4, 0xe3, 0x18,
								   0x12, 0x80, 0x86, 0x23, 0xec, 0x68, 0xa8, 0xeb, 0x5e, 0x07, 0x63, 0xa2, 0x5d, 0xcb,
								   0xbf, 0xfc, 0x58, 0x35, 0xe3, 0xe9, 0x79, 0x09, 0x36, 0xf4, 0xf1, 0x4b, 0xb3, 0xc6,
								   0xf8, 0x40, 0x22, 0xb9, 0x1b, 0xb9, 0x86, 0xca, 0xf1, 0xbe, 0xe0, 0xed, 0x94, 0x5b,
								   0xbb, 0x25, 0x4c, 0xd3, 0xe3, 0x77, 0xed, 0xda, 0x10, 0x67, 0x63, 0x6a, 0xaf, 0x2e,
								   0xa2, 0xae, 0x34, 0xa6, 0xb9, 0x54, 0x84, 0x74, 0xe8, 0x45, 0x8a, 0x66, 0x4a, 0x39,
								   0xd8, 0x93, 0x3a, 0xfa, 0xed, 0x85, 0x7a, 0xc1, 0x62, 0x94, 0x46, 0xf3, 0x89, 0x27,
								   0xfc, 0x79, 0xb9, 0x89, 0xc5, 0xa6, 0xaf, 0x6a, 0xe7, 0xfd, 0x37, 0x94, 0xe9, 0xc2,
								   0x1a, 0x4d, 0x7a, 0xc9, 0xe1, 0x22, 0xb7, 0xcc, 0xba, 0xd0, 0x9a, 0x3c, 0x62, 0xbb,
								   0x2f, 0x3c, 0x8b, 0xd9, 0x44, 0x1e, 0x4f, 0x0e, 0xbc, 0xd7, 0x68, 0xab, 0x42, 0x53,
								   0x60, 0x28, 0xca, 0xa5, 0x76, 0x6d, 0xb0, 0xce, 0x8e, 0xdb, 0xcc, 0x8a, 0x65, 0xa1,
								   0x67, 0x77, 0x6c, 0xfd, 0x5a, 0x6e, 0x04, 0xef, 0xe4, 0xfe, 0xfb, 0xb9, 0x46, 0x18,
								   0xbf, 0xaf, 0xfb, 0xab, 0x6e, 0xed, 0xf2, 0xe8, 0xec, 0x26, 0x12, 0x4e, 0x9b, 0xaa,
								   0x1b, 0xf9, 0x7c, 0x95, 0xa7, 0xb2, 0x2d, 0x14, 0x45, 0x4a, 0xc6, 0xe6, 0x96, 0xe6,
								   0x32, 0x55, 0x54, 0x77, 0x67, 0x8a, 0xd7, 0x0a, 0x3f, 0xeb, 0xa8, 0x21, 0xd4, 0x53,
								   0x6b, 0xe8, 0xd9, 0xff, 0xa5, 0x96, 0x50, 0xee, 0x7e, 0xdc, 0xc3, 0x59, 0x83, 0xd7,
								   0xd0, 0xde, 0xb0, 0x59
								 };

	unsigned char g_buf_2048[] = { 0x7d, 0x45, 0x65, 0x29, 0x8f, 0x49, 0x56, 0x29, 0x40, 0x06, 0xd2, 0x54, 0xcd, 0x2f, 0x67,
								   0xfc, 0x8d, 0xed, 0x8e, 0x10, 0x68, 0xb0, 0xf8, 0x96, 0x75, 0xb8, 0x27, 0x31, 0x94, 0xa2,
								   0xca, 0x70, 0x7b, 0x91, 0x3c, 0x65, 0x02, 0x49, 0x93, 0x34, 0x8b, 0xd6, 0x16, 0xf2, 0x92,
								   0x44, 0xe8, 0x08, 0x03, 0xe7, 0x8f, 0x2a, 0xd4, 0x99, 0xdb, 0x89, 0x56, 0x83, 0x10, 0x06,
								   0x57, 0x0c, 0x2f, 0x97, 0xa0, 0xb1, 0xb6, 0x16, 0x68, 0x14, 0xb1, 0x07, 0x6b, 0xc2, 0x7c,
								   0xa8, 0x26, 0xe8, 0x3a, 0xbb, 0xf5, 0xd7, 0x1c, 0x52, 0x5e, 0x8c, 0x38, 0x24, 0x36, 0xc1,
								   0xa9, 0x97, 0xfe, 0x15, 0xbe, 0x09, 0x5f, 0x85, 0x0f, 0x48, 0x7c, 0x36, 0xb9, 0x50, 0x64,
								   0x61, 0xab, 0x7f, 0x6e, 0x17, 0x04, 0x35, 0x1a, 0x19, 0xd0, 0xb5, 0x37, 0xfe, 0xc7, 0xbd,
								   0xc4, 0xc4, 0x48, 0xca, 0xfa, 0x96, 0xfe, 0x86, 0x25, 0x81, 0xd0, 0xb0, 0x76, 0x04, 0xb8,
								   0x94, 0x37, 0x6c, 0x17, 0x46, 0xc7, 0x04, 0xc9, 0xd8, 0x92, 0x38, 0x41, 0x32, 0x87, 0x63,
								   0x97, 0x22, 0x2e, 0x5f, 0x0a, 0x0b, 0x2f, 0xa1, 0x55, 0x95, 0x67, 0xb1, 0x9b, 0xbe, 0xb1,
								   0x06, 0x8a, 0x1c, 0x10, 0xa8, 0x10, 0x46, 0xe7, 0xe7, 0x14, 0xd2, 0x3c, 0xf9, 0xb5, 0xff,
								   0xf3, 0x36, 0xda, 0x62, 0xce, 0xeb, 0x36, 0xbe, 0x3d, 0xce, 0x6c, 0x99, 0xbd, 0xe1, 0x14,
								   0x29, 0x51, 0x4f, 0x5b, 0x64, 0xe4, 0x34, 0x6b, 0xad, 0x74, 0xfe, 0x5d, 0xc0, 0x6f, 0x4f,
								   0xb7, 0x6a, 0x1e, 0x4c, 0xc2, 0xdb, 0x73, 0x11, 0x09, 0x91, 0x77, 0x2f, 0xfc, 0x8e, 0x8a,
								   0xd7, 0xf5, 0x42, 0x7a, 0x2c, 0x61, 0x7f, 0x0f, 0xb0, 0xe3, 0x32, 0x99, 0x54, 0xc8, 0x26,
								   0xbf, 0xbe, 0xf0, 0xe9, 0x0a, 0x8e, 0xd4, 0x59, 0x85, 0x60, 0x8d, 0x1b, 0x32, 0x6b, 0xe0,
								   0x6e
								 };

	unsigned char output[300];
	unsigned int object_id[2] = { OID_DH_1024, OID_DH_2048 }, olen;

	printf("----------------------------------------------\n");
	printf("TESTCASE : see_generate/compute_dhm_params\n");
	printf("----------------------------------------------\n");

	memset(&d_param, 0, sizeof(struct sDH_PARAM));

	d_param.modules_p = p_buf_1024;
	d_param.generator_g = g_buf_1024;
	d_param.modules_p_byte_len = 128;
	d_param.generator_g_byte_len = 128;

	d_param.publickey = (unsigned char *)malloc(d_param.modules_p_byte_len);
	d_param.publickey_byte_len = d_param.modules_p_byte_len;

	memset(d_param.publickey, 0, d_param.publickey_byte_len);
	d_param.object_id = object_id[0];

	for (i = 0; i < 9; i++) {
		see_selfprintf("[%d] ", i);

		ret = see_generate_dhm_params(&d_param, i);
		ret += see_compute_dhm_param(&d_param, i, output, &olen);
		if (i == 8 && ret) {
			see_selfprintf(" success\n");
		} else if (ret) {
			test_result |= 0x200;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}

	free(d_param.publickey);

	d_param.modules_p = p_buf_2048;
	d_param.generator_g = g_buf_2048;
	d_param.modules_p_byte_len = 256;
	d_param.generator_g_byte_len = 256;

	d_param.publickey = (unsigned char *)malloc(d_param.modules_p_byte_len);
	d_param.publickey_byte_len = d_param.modules_p_byte_len;

	memset(d_param.publickey, 0, d_param.publickey_byte_len);
	d_param.object_id = object_id[1];

	for (i = 0; i < 9; i++) {
		see_selfprintf("[%d] ", i);

		ret = see_generate_dhm_params(&d_param, i);
		ret += see_compute_dhm_param(&d_param, i, output, &olen);
		if (i == 8 && ret) {
			see_selfprintf(" success\n");
		} else if (ret) {
			test_result |= 0x200;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}

	free(d_param.publickey);

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_rsa_encrypt_decrypt(void)
{
	int ret = 1;
	int i = 0;
	unsigned int test_result = 0;
	unsigned int inlen, outlen, checklen;
	unsigned char input[128];
	unsigned char output[128];
	unsigned char check[128];

	printf("----------------------------------------\n");
	printf("TESTCASE : see_rsa_encrypt/decrypt\n");
	printf("----------------------------------------\n");

	inlen = 128;
	checklen = 128;

	for (i = 0; i < 9; i++) {
		see_selfprintf("[%d] ", i);

		memset(input, i + 1, 128);

		see_setup_key(test_rsa_dev, 1192, SECURE_STORAGE_TYPE_KEY_RSA, i);
		ret = see_rsa_encryption(i, MBEDTLS_RSA_PKCS_V15, output, &outlen, input, inlen);

		ret += see_rsa_decryption(i, MBEDTLS_RSA_PKCS_V15, check, &checklen, output, outlen);

		if (i == 8 && ret) {
			see_selfprintf(" success\n");
		} else if (ret || memcmp(input, check, checklen)) {
			test_result |= 0x400;
			see_selfprintf(" fail\n");
			break;
		} else {
			see_selfprintf(" success\n");
		}
	}

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_get_verify_rsa_signature(void)
{
	int ret = 1;
	int i = 0;
	int j = 0;
	unsigned int test_result = 0;
	unsigned int algo_type[8] = { 0x1100, 0x1101, 0x2300, 0x2301,
								  0x2400, 0x2401, 0x2500, 0x2501
								};
	unsigned int hash_size[8] = { 20, 20, 32, 32, 48, 48, 64, 64 };
	unsigned char sig_buf[1000];
	unsigned char hash[100];
	struct sRSA_SIGN rsa_sign;

	printf("------------------------------------------\n");
	printf("TESTCASE : see_get/verify_rsa_signature\n");
	printf("------------------------------------------\n");

	memset(&rsa_sign, 0, sizeof(struct sRSA_SIGN));

	rsa_sign.signature = sig_buf;
	rsa_sign.signature_byte_len = 1000;

	for (i = 0; i < 9; i++) {
		see_setup_key(test_rsa_dev, 1192, SECURE_STORAGE_TYPE_KEY_RSA, i);
		for (j = 0; j < 8; j++) {
			see_selfprintf("[%d] ", j + i * 8);

			rsa_sign.alg_type = algo_type[j];

			ret = see_get_rsa_signature(&rsa_sign, hash, hash_size[j], i);
			ret += see_verify_rsa_signature(&rsa_sign, hash, hash_size[j], i);

			if (i == 8 && ret) {
				see_selfprintf(" success\n");
			} else if (ret) {
				test_result |= 0x800;
				see_selfprintf(" fail\n");
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_get_verify_ecdsa_signature(void)
{
	int ret = 1;
	int i = 0;
	int j = 0;
	unsigned int test_result = 0;
	unsigned int alg_input[8] = { OID_ECDSA_BP256_SHA1_160, OID_ECDSA_BP256_SHA2_256,
								  OID_ECDSA_BP256_SHA2_384, OID_ECDSA_BP256_SHA2_512,
								  OID_ECDSA_P521_SHA1_160, OID_ECDSA_P521_SHA2_256,
								  OID_ECDSA_P521_SHA2_384, OID_ECDSA_P521_SHA2_512
								};
	unsigned int hash_size[8] = { 20, 32, 48, 64, 20, 32, 48, 64 };
	unsigned char r_buf[100];
	unsigned char s_buf[100];
	unsigned char hash[100];
	struct sECC_SIGN ecc_sign;

	printf("--------------------------------------------\n");
	printf("TESTCASE : see_get/verify_ecdsa_signature\n");
	printf("--------------------------------------------\n");

	memset(&ecc_sign, 0, sizeof(struct sECC_SIGN));

	ecc_sign.r = r_buf;
	ecc_sign.s = s_buf;
	ecc_sign.r_byte_len = 100;
	ecc_sign.s_byte_len = 100;

	for (i = 0; i < 9; i++) {
		for (j = 0; j < 4; j++) {
			see_selfprintf("[%d] ", i * 4 + j);
			ecc_sign.sign_type = alg_input[j];

			see_setup_key(test_ecdsa_dev_bp, 122, SECURE_STORAGE_TYPE_KEY_ECC, i);

			ret = see_get_ecdsa_signature(&ecc_sign, hash, hash_size[j], i);
			ret += see_verify_ecdsa_signature(&ecc_sign, hash, hash_size[j], i);

			if (i == 8 && ret) {
				see_selfprintf(" success\n");
			} else if (ret) {
				test_result |= 0x1000;
				see_selfprintf(" fail %d\n", ret);
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	for (i = 0; i < 9; i++) {
		for (j = 4; j < 8; j++) {
			see_selfprintf("[%d] ", 36 + i * 4 + j - 4);
			ecc_sign.sign_type = alg_input[j];

			see_setup_key(test_ecdsa_dev_nist, 223, SECURE_STORAGE_TYPE_KEY_ECC, i);

			ret = see_get_ecdsa_signature(&ecc_sign, hash, hash_size[j], i);
			ret += see_verify_ecdsa_signature(&ecc_sign, hash, hash_size[j], i);

			if (i == 8 && ret) {
				see_selfprintf(" success\n");
			} else if (ret) {
				test_result |= 0x1000;
				see_selfprintf(" fail\n");
				break;
			} else {
				see_selfprintf(" success\n");
			}
		}
	}

	isp_clear(0);
	return test_result;
}

unsigned int TC_see_iotivity_read_write(void)
{
	int ret = 1;
	int i = 0;
	unsigned int test_result = 0;

	int expected_ret[9] = { SEE_INVALID_INPUT_PARAMS,
							SEE_OK,
							SEE_OK,
							SEE_OK,
							SEE_OK,
							SEE_OK,
							SEE_OK,
							SEE_OK,
							SEE_INVALID_INPUT_PARAMS
						  };

	unsigned int buflen[9] = { 0, 100, 1000, 4088, 4096, 5000, 6000,
							   SEE_IOTIVITY_MAXSIZE, SEE_IOTIVITY_MAXSIZE + 1
							 };
	unsigned int outlen = 0;
	unsigned char inbuf[SEE_MAX_BUF_SIZE * 2 + 100];
	unsigned char outbuf[SEE_MAX_BUF_SIZE * 2 + 100];

	printf("------------------------------------------\n");
	printf("TESTCASE : see_iotivity_read_write\n");
	printf("------------------------------------------\n");

	for (i = 0; i < 9; i++) {
		see_selfprintf("[%d] ", i);

		memset(inbuf, i, SEE_MAX_BUF_SIZE * 2 + 100);

		ret = see_write_iotivity_storage(inbuf, buflen[i]);

		if (ret != expected_ret[i]) {
			test_result |= 0x2;
			see_selfprintf(" fail ");
			see_selfprintf("expected result %d, actual return %d\n", expected_ret[i], ret);
			break;
		}

		if (i == 8) {
			continue;
		}

		outlen = 0;
		memset(outbuf, 0, SEE_MAX_BUF_SIZE * 2 + 100);

		ret = see_read_iotivity_storage(outbuf, buflen[i], &outlen);

		if (ret == expected_ret[i] && buflen[i] == outlen && !memcmp(inbuf, outbuf, buflen[i])) {
			see_selfprintf(" success\n");
		} else {
			test_result |= 0x2;
			see_selfprintf(" fail ");
			see_selfprintf("expected result %d, actual return %d ", expected_ret[i], ret);
			see_selfprintf("inlen %d, outlen %d\n", buflen[i], outlen);
			break;
		}
	}

	isp_clear(0);
	return test_result;
}

#define SEE_KEYNUM	6
#define SEE_CERTNUM	1
#define SEE_HASHNUM	4
#define ARTIK_CURVE	OID_ECC_P256

struct fac_info {
	int id;
	char *name;
};

int print_crt(int debug_mode, unsigned char *buf, unsigned int buf_len)
{
	int ret = 0;
	int pos = 0;
	size_t len = 0;
	unsigned char *p = NULL;
	int buf_format = MBEDTLS_X509_FORMAT_DER;

	if (debug_mode != 1) {
		return 0;
	}

	if (!buf) {
		ret = -1;
		goto exit;
	}

	mbedtls_x509_crt crt;
	mbedtls_x509_crt *t_crt;

	mbedtls_x509_crt_init(&crt);

	if (strstr((const char *)buf, "-----BEGIN CERTIFICATE-----") != NULL) {
		buf_format = MBEDTLS_X509_FORMAT_PEM;
	}

	if (buf_format == MBEDTLS_X509_FORMAT_DER) {

		p = (unsigned char *)buf;

		while (pos < buf_len) {
			p = (unsigned char *)buf + pos;
			ret = mbedtls_asn1_get_tag(&p, buf + buf_len, &len, MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
			if (ret != 0) {
				goto exit;
			}
			if ((pos + len) < buf_len) {
				ret = mbedtls_x509_crt_parse(&crt, buf + pos, len + 4);
				if (ret != 0) {
					goto exit;
				}
			}
			pos += len + 4;
		}
	} else {
		ret = mbedtls_x509_crt_parse(&crt, buf, buf_len);
		if (ret != 0) {
			goto exit;
		}
	}

	t_crt = &crt;

	while (t_crt != NULL) {
		ret = mbedtls_x509_crt_info((char *)buf, buf_len, "  - ", t_crt);
		if (ret <= 0) {
			goto exit;
		}
		printf("\n%s\n", buf);
		t_crt = t_crt->next;
	}

	mbedtls_x509_crt_free(&crt);
	return 0;

exit:
	mbedtls_x509_crt_free(&crt);
	return ret;
}

unsigned int g_cert_existence[1][2] = { {FACTORYKEY_ARTIK_CERT, 0} };

unsigned int g_key_existence[1][2] = { {FACTORYKEY_ARTIK_DEVICE, 0} };

void print_existence(void)
{
	unsigned char cert[1][20] = { "ARTIK CERT" };

	unsigned char key[1][20] = { "ARTIK DEV" };

	int i;

	for (i = 0; i < 1; i++) {
		if (g_cert_existence[i][1]) {
			printf("%s", "[ O ]");
		} else {
			printf("%s", "[ X ]");
		}
		printf(" %s\n", cert[i]);
	}
	for (i = 0; i < 1; i++) {
		if (g_key_existence[i][1]) {
			printf("%s", "[ O ]");
		} else {
			printf("%s", "[ X ]");
		}
		printf(" %s\n", key[i]);
	}
}

void init_existence(void)
{
	int i;

	for (i = 0; i < 1; i++) {
		g_cert_existence[i][1] = 0;
	}
	for (i = 0; i < 1; i++) {
		g_key_existence[i][1] = 0;
	}
}

void set_existence(unsigned int id)
{
	int i;

	for (i = 0; i < 1; i++) {
		if (g_cert_existence[i][0] == id) {
			g_cert_existence[i][1] = 1;
			return;
		}
	}
	for (i = 0; i < 1; i++) {
		if (g_key_existence[i][0] == id) {
			g_key_existence[i][1] = 1;
			return;
		}
	}
}

void TC_see_factory_getcert(int debug_mode)
{
	int ret = 0;
	int i = 0;
	struct fac_info cert[SEE_CERTNUM] = { {FACTORYKEY_ARTIK_CERT, "ARTIK CERT"} };

	unsigned int buf_len = 4096;
	unsigned char *buf = (unsigned char *)malloc(buf_len * sizeof(unsigned char));
	if (!buf) {
		printf("malloc is failed\n");
		return;
	}

	while (i < SEE_CERTNUM) {
		printf("[%d] %s ... ", i, cert[i].name);
		buf_len = 4096;

		ret = see_get_certificate(buf, &buf_len, cert[i].id, 0);
		if (ret != 0) {
			printf("get failed : %d\n", ret);
			i++;
			continue;
		}
		ret = print_crt(debug_mode, buf, buf_len);

		if (ret) {
			printf("parse failed : %x\n", -ret);
			i++;
			continue;
		}
		set_existence(cert[i].id);
		i++;
		printf("success\n");
	}

	free(buf);
}

void TC_see_factory_ecctest(int debug_mode, unsigned int index, unsigned int curve)
{
	int i = 0;
	int ret = 0;

	struct sECC_SIGN ecc_sign;
	struct sECC_KEY ecc_key;

	printf("--------------- sign/verify start --------------\n");

	unsigned int input[SEE_HASHNUM] = { OID_SHA1_160, OID_SHA2_256,
										OID_SHA2_384, OID_SHA2_512
									  };
	unsigned int hash_len[SEE_HASHNUM] = { 20, 32, 48, 64 };
	unsigned char hash[64];

	unsigned char r[68];
	unsigned char s[68];

	memset(&ecc_sign, 0, sizeof(struct sECC_SIGN));

	ecc_sign.r = r;
	ecc_sign.s = s;

	while (i < SEE_HASHNUM) {
		printf("[%d] ECC key test (hashlen %d) ...\n", i, hash_len[i]);

		ecc_sign.sign_type = curve | input[i];
		ret = see_get_ecdsa_signature(&ecc_sign, hash, hash_len[i], index);
		if (ret != 0) {
			printf("sign failed : %d\n", ret);
			break;
		}
		printf("sign success\n");

		ret = see_verify_ecdsa_signature(&ecc_sign, hash, hash_len[i], index);
		if (ret != 0) {
			printf("verify failed : %d\n", ret);
			break;
		}
		printf("verify success\n");

		i++;
	}

	while (!ret) {
		printf("[%d] GET ARTIK PUBKEY ... ", i);
		ecc_key.curve = curve;
		ecc_key.publickey_x = r;
		ecc_key.publickey_y = s;
		ecc_key.x_byte_len = sizeof(r);
		ecc_key.y_byte_len = sizeof(s);

		ret = see_get_ecc_publickey(&ecc_key, index, curve);
		if (ret != 0) {
			break;
		}
		printf("success\n");

		if (debug_mode) {
			printf("publickey X size : %d\n", ecc_key.x_byte_len);
			for (i = 0; i < ecc_key.x_byte_len; i++) {
				printf("%x ", (ecc_key.publickey_x)[i]);
				if (i % 16 == 15) {
					printf("\n");
				}
			}
			printf("\npublickey Y size : %d\n", ecc_key.y_byte_len);
			for (i = 0; i < ecc_key.y_byte_len; i++) {
				printf("%x ", (ecc_key.publickey_y)[i]);
				if (i % 16 == 15) {
					printf("\n");
				}
			}
		}
		break;
	}
	if (ret) {
		printf("failed : %d\n", ret);
	} else {
		set_existence(index);
	}
}

void TC_see_factory_key_test(int debug_mode)
{
	if (debug_mode < 0) {
		return;
	}

	printf("\n------------------------------------------\n");
	printf("TESTCASE : GET FACTORY cert\n");
	printf("------------------------------------------\n");

	TC_see_factory_getcert(debug_mode);

	printf("\n------------------------------------------\n");
	printf("TESTCASE : ARTIK key\n");
	printf("------------------------------------------\n");

	TC_see_factory_ecctest(debug_mode, FACTORYKEY_ARTIK_DEVICE, ARTIK_CURVE);
}

void TC_see_get_uuid(int debug_mode)
{
	unsigned char uuid[64] = { 0x00, };
	unsigned int uuid_len = 0;
	unsigned int ret = 0;
	int i;

	if (debug_mode < 0) {
		return;
	}

	ret = get_artik_crt_uuid(uuid, &uuid_len);
	if (ret) {
		printf("Failed to get uuid (err:0x%x)", ret);
		return;
	}

	printf("uuid : ");
	for (i = 0; i < uuid_len; i++) {
		printf("%c", uuid[i]);
	}

	printf("\n");
}

#define PUFKEY_NUM	1024

typedef struct {
	unsigned char puf[64];
	unsigned int puflen;
	unsigned char input[64];
} pufkey_t;

static pufkey_t pufkey[PUFKEY_NUM];

void TC_puf_key_test(int debug_mode)
{
	unsigned int input_len = 0;
//  unsigned char comp_puf[PUFKEY_NUM] = { 0x00, };
//  unsigned int comp_puflen = 0;
	int ret = 0;
	int i;
	int j;

	input_len = debug_mode;

	printf("------------------------------------------\n");
	printf("TESTCASE : TC_puf_key_test (len:%d)\n", input_len);
	printf("------------------------------------------\n");

	if (input_len > 55 || input_len < 1) {
		see_selfprintf("Invalid input length!!\n");
		return;
	}

	see_selfprintf("[Key generation check  (%d)] ", PUFKEY_NUM);
	for (i = 0; i < PUFKEY_NUM; i++) {

		ret = see_generate_random((unsigned int *)pufkey[i].input, input_len);
		/*
		   ret += isp_kdf(&pufkey[i].puflen, pufkey[i].puf,
		   input_len, pufkey[i].input);
		   ret += isp_kdf(&comp_puflen, comp_puf, input_len, pufkey[i].input);

		   if (memcmp(pufkey[i].puf, comp_puf, 32)) {
		   ret++;
		   }
		 */
	}
	if (ret) {
		see_selfprintf(" fail\n");
	} else {
		see_selfprintf(" success\n");
	}

	ret = 0;
	see_selfprintf("[Key duplication check (%d)] ", PUFKEY_NUM);

	for (i = 0; i < PUFKEY_NUM; i++) {
		for (j = i + 1; j < PUFKEY_NUM; j++) {
			if ((!memcmp(pufkey[i].puf, pufkey[j].puf, 32)) && (memcmp(pufkey[i].input, pufkey[j].input, input_len))) {
				ret++;
			}
		}
	}
	if (ret) {
		see_selfprintf(" fail\n");
	} else {
		see_selfprintf(" success\n");
	}
}

pthread_addr_t see_test_cb(void *args)
{
	int i;
	int test_result = 0;
	int debug_mode = 0;
	int factory_test = 0;
	int get_uuid = 0;
	int puf_test = 0;
	unsigned int test_select = 0x1fff;	// FULL TEST = 0x1fff;

	int argc;
	char **argv;
	char *p;
	char *q;

	argc = ((struct pthread_arg *)args)->argc;
	argv = ((struct pthread_arg *)args)->argv;

#if defined(CONFIG_TLS_WITH_HW_ACCEL)
	see_init();
#endif

	for (i = 1; i < argc; i++) {
		p = argv[i];
		q = strchr(p, '=');
		if (q == NULL) {
			break;
		}

		*q++ = '\0';

		if ((strcmp(p, "test_select")) == 0) {
			test_select = atoi(q);
		}

		if ((strcmp(p, "fac")) == 0) {
			debug_mode = atoi(q);
			factory_test = 1;
		}

		if (strcmp(p, "uuid") == 0) {
			debug_mode = atoi(q);
			get_uuid = 1;
		}

		if (strcmp(p, "puf") == 0) {
			debug_mode = atoi(q);
			puf_test = 1;
		}

	}

	if (factory_test) {
		init_existence();
		TC_see_factory_key_test(debug_mode);

		printf("\n\n-----------------\n");
		printf("Key existence\n");
		printf("-----------------\n");
		print_existence();
		printf("\n");
		return 0;
	}

	if (get_uuid) {
		TC_see_get_uuid(debug_mode);
		printf("\n");
		return 0;
	}

	if (puf_test) {
		TC_puf_key_test(debug_mode);
		printf("\n");
		return 0;
	}

	unsigned char test_name[13][50] = { "see_read_write_secure_storage",
										"see_iotivity_read_write",
										"see_generate_key",
										"see_setup/remove_key",
										"see_aes_encrypt/decrypt",
										"see_get_hash",
										"see_get_random",
										"see_get_hmac",
										"see_generate_certificate",
										"see_generate/compute_dhm_params",
										"see_rsa_encrypt/decrypt",
										"see_get/verify_rsa_signature",
										"see_get/verify_ecdsa_signature"
									  };

	printf("\n\n");

	if (test_select & 0x1) {
		test_result |= TC_see_read_write_secure_storage();
	}
	if (test_select & 0x2) {
		test_result |= TC_see_iotivity_read_write();
	}
	if (test_select & 0x4) {
		test_result |= TC_see_generate_key();
	}
	if (test_select & 0x8) {
		test_result |= TC_see_setup_remove_key();
	}
	if (test_select & 0x10) {
		test_result |= TC_see_aes_encrypt_decrypt();
	}
	if (test_select & 0x20) {
		test_result |= TC_see_get_hash();
	}
	if (test_select & 0x40) {
		test_result |= TC_see_get_random();
	}
	if (test_select & 0x80) {
		test_result |= TC_see_get_hmac();
	}
	if (test_select & 0x100) {
		test_result |= TC_see_generate_certificate();
	}
	if (test_select & 0x200) {
		test_result |= TC_see_generate_dhm_params();
	}
	if (test_select & 0x400) {
		test_result |= TC_see_rsa_encrypt_decrypt();
	}
	if (test_select & 0x800) {
		test_result |= TC_see_get_verify_rsa_signature();
	}
	if (test_select & 0x1000) {
		test_result |= TC_see_get_verify_ecdsa_signature();
	}

	for (i = 0; i < 13; i++) {
		if (!(test_select & 0x1)) {
			printf("%40s not tested\n", test_name[i]);
		} else if (test_result & 0x1) {
			printf("%40s fail\n", test_name[i]);
		} else {
			printf("%40s success\n", test_name[i]);
		}
		test_result = test_result >> 1;
		test_select = test_select >> 1;
	}

	printf("=====SSS Block Test Finish=====\n");
#if defined(CONFIG_TLS_WITH_HW_ACCEL)
	see_free();
#endif

	return NULL;
}

int security_see_test_main(int argc, char **argv)
{
	pthread_t tid;
	pthread_attr_t attr;
	struct sched_param sparam;
	int r;

	struct pthread_arg args;

	args.argc = argc;
	args.argv = argv;

	/* Initialize the attribute variable */
	r = pthread_attr_init(&attr);
	if (r != 0) {
		printf("%s: pthread_attr_init failed, status=%d\n", __func__, r);
	}

	/* 1. set a priority */
	sparam.sched_priority = SEE_TEST_PRIORITY;
	r = pthread_attr_setschedparam(&attr, &sparam);
	if (r != 0) {
		printf("%s: pthread_attr_setschedparam failed, status=%d\n", __func__, r);
	}

	r = pthread_attr_setschedpolicy(&attr, SEE_TEST_SCHED_POLICY);
	if (r != 0) {
		printf("%s: pthread_attr_setschedpolicy failed, status=%d\n", __func__, r);
	}

	/* 2. set a stacksize */
	r = pthread_attr_setstacksize(&attr, SEE_TEST_STACK_SIZE);
	if (r != 0) {
		printf("%s: pthread_attr_setstacksize failed, status=%d\n", __func__, r);
	}

	/* 3. create pthread with entry function */
	r = pthread_create(&tid, &attr, see_test_cb, (void *)&args);
	if (r != 0) {
		printf("%s: pthread_create failed, status=%d\n", __func__, r);
	}

	/* Wait for the threads to stop */
	r = pthread_join(tid, NULL);
	if (r != 0) {
		printf("%s: pthread_join failed, status=%d\n", __func__, r);
	}

	return 0;
}
